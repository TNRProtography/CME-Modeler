import React, { useEffect, useRef } from 'react';

const ForecastDashboard: React.FC = () => {
    const auroraChartRef = useRef<HTMLCanvasElement>(null);
    const magneticChartRef = useRef<HTMLCanvasElement>(null);

    useEffect(() => {
        let auroraChartInstance: any = null;
        let magneticChart: any = null;
        let apiDataCache: Record<string, any> = {};

        const NOAA_PLASMA_ENDPOINT = 'https://services.swpc.noaa.gov/products/solar-wind/plasma-5-minute.json';
        const NOAA_MAG_ENDPOINT = 'https://services.swpc.noaa.gov/products/solar-wind/mag-1-day.json';
        const GAUGE_API_ENDPOINTS = {
            power: 'https://hemispheric-power.thenamesrock.workers.dev/',
            speed: NOAA_PLASMA_ENDPOINT,
            density: NOAA_PLASMA_ENDPOINT,
            bt: NOAA_MAG_ENDPOINT,
            bz: NOAA_MAG_ENDPOINT
        };
        const GAUGE_THRESHOLDS = { speed: { gray: 250, yellow: 350, orange: 500, red: 650, purple: 800, pink: Infinity, maxExpected: 1000 }, density: { gray: 5, yellow: 10, orange: 15, red: 20, purple: 50, pink: Infinity, maxExpected: 70 }, power: { gray: 20, yellow: 40, orange: 70, red: 150, purple: 200, pink: Infinity, maxExpected: 250 }, bt: { gray: 5, yellow: 10, orange: 15, red: 20, purple: 50, pink: Infinity, maxExpected: 60 }, bz: { gray: -5, yellow: -10, orange: -15, red: -20, purple: -50, pink: -50, maxNegativeExpected: -60 }};
        const GAUGE_COLORS = { gray: '#808080', yellow: '#FFD700', orange: '#FFA500', red: '#FF4500', purple: '#800080', pink: '#FF1493' };
        const GAUGE_EMOJIS = { gray: '\u{1F610}', yellow: '\u{1F642}', orange: '\u{1F642}', red: '\u{1F604}', purple: '\u{1F60D}', pink: '\u{1F60D}', error: '\u{2753}' };
        const UPDATE_INTERVAL_MS = 600000;
        const CHART_HOURS = 24;

        function formatTimestamp(isoString: string) { try { const d = new Date(isoString); return isNaN(d.getTime()) ? "Invalid Date" : `${d.toLocaleDateString()} ${d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`; } catch { return "Invalid Date"; } }
        function getGaugeStyle(v: number | null, t: string): { color: string; emoji: string; percentage: number; } { if (v == null || isNaN(v)) return { color: GAUGE_COLORS.gray, emoji: GAUGE_EMOJIS.error, percentage: 0 }; let k='pink', p=0; if (t==='bz') { const th=GAUGE_THRESHOLDS.bz; k=v<=th.pink?'pink':v<=th.purple?'purple':v<=th.red?'red':v<=th.orange?'orange':v<=th.yellow?'yellow':'gray'; p=v<0?Math.min(100,Math.max(0,(v/th.maxNegativeExpected)*100)):0; } else { const th=GAUGE_THRESHOLDS[t as keyof typeof GAUGE_THRESHOLDS]; k=v<=th.gray?'gray':v<=th.yellow?'yellow':v<=th.orange?'orange':v<=th.red?'red':v<=th.purple?'purple':'pink'; p=Math.min(100,Math.max(0,(v/th.maxExpected)*100)); } return { color: GAUGE_COLORS[k as keyof typeof GAUGE_COLORS], emoji: GAUGE_EMOJIS[k as keyof typeof GAUGE_EMOJIS], percentage: p }; }
        async function updateGauge(type: string) { /* Implementation below */ }
        async function renderMagneticChart() { /* Implementation below */ }
        async function fetchSensor() { /* Implementation below */ }
        function getAuroraEmoji(s: number) {return s<10?'\u{1F61F}':s<25?'\u{1F610}':s<50?'\u{1F642}':s<80?'\u{1F600}':'\u{1F929}'}
        function updateThermometer(s: number) { const t=document.getElementById('thermometer-line') as HTMLElement;if(t)t.style.width=Math.min(s,100)+'%';if(t)t.style.backgroundColor=s<10?'#808080':s<25?'#FFD700':s<40?'#FFA500':s<50?'#FF4500':s<80?'#800080':'#FF1493' }
        function updateAuroraBlurb(s: number) { document.querySelectorAll('#aurora-blurbs .aurora-blurb').forEach(e=>(e as HTMLElement).style.display='none'); (document.getElementById(s<10?'blurb-10':s<25?'blurb-25':s<40?'blurb-40':s<50?'blurb-50':s<80?'blurb-80':'blurb-80plus') as HTMLElement).style.display='block' }
        async function renderAuroraChart() { /* Implementation below */ }

        async function updateGauge(type: string) {
            const endpoint = GAUGE_API_ENDPOINTS[type as keyof typeof GAUGE_API_ENDPOINTS]; const elements = { value: document.getElementById(`${type}-value`), emoji: document.getElementById(`${type}-emoji`), lastUpdated: document.getElementById(`${type}-last-updated`), bar: document.getElementById(`${type}-gauge-bar`) }; if (!elements.value || !elements.emoji || !elements.lastUpdated || !elements.bar) return;
            try { if (type === 'power') { const response = await fetch(endpoint); if (!response.ok) throw new Error(`Fetch failed`); const data = await response.json(); const latestData = data.values[data.values.length - 1]; const value = parseFloat(latestData.value); const style = getGaugeStyle(value, type); elements.value.innerText = `${value.toFixed(1)} GW`; elements.emoji.innerHTML = style.emoji; elements.lastUpdated.innerText = `Last Updated: ${formatTimestamp(latestData.lastUpdated)}`; elements.bar.style.width = `${style.percentage}%`; elements.bar.style.backgroundColor = style.color; return; } let data = apiDataCache[endpoint]; if (!data) { const response = await fetch(endpoint); if (!response.ok) throw new Error(`Network error`); data = await response.json(); apiDataCache[endpoint] = data; } if (!Array.isArray(data) || data.length < 2) throw new Error("Invalid NOAA format"); const headers = data[0]; const columnName = type === 'bz' ? 'bz_gsm' : type; const valueIndex = headers.indexOf(columnName); const timeIndex = headers.indexOf('time_tag'); if (valueIndex === -1 || timeIndex === -1) throw new Error(`Column not found`); let latestRow = null; for (let i = data.length - 1; i > 0; i--) { const row = data[i]; const val = parseFloat(row[valueIndex]); if (!isNaN(val) && val > -9999) { latestRow = row; break; } } if (!latestRow) throw new Error("No valid data"); const value = parseFloat(latestRow[valueIndex]); const lastUpdated = latestRow[timeIndex]; const unit = type==='speed'?' km/s':type==='density'?' p/cm³': ' nT'; const style = getGaugeStyle(value, type); elements.value.innerText = `${value.toFixed(1)}${unit}`; elements.emoji.innerHTML = style.emoji; elements.lastUpdated.innerText = `Last Updated: ${formatTimestamp(lastUpdated)}`; elements.bar.style.width = `${style.percentage}%`; elements.bar.style.backgroundColor = style.color; } catch (error) { elements.value.innerText = "Error"; elements.emoji.innerHTML = GAUGE_EMOJIS.error; elements.lastUpdated.innerText = `Failed: ${(error as Error).message.substring(0,30)}`; elements.bar.style.width='0%'; }
        }
        async function renderMagneticChart() {
            const ctx = magneticChartRef.current?.getContext('2d'); if (!ctx) return; const chartTimeLimit = new Date(Date.now() - CHART_HOURS * 3600 * 1000);
            try { let data = apiDataCache[NOAA_MAG_ENDPOINT]; if (!data) { const response = await fetch(NOAA_MAG_ENDPOINT); if (!response.ok) throw new Error(`Fetch failed`); data = await response.json(); apiDataCache[NOAA_MAG_ENDPOINT] = data; } if (!Array.isArray(data) || data.length < 2) throw new Error("Invalid NOAA format"); const headers = data[0]; const timeIndex = headers.indexOf('time_tag'); const btIndex = headers.indexOf('bt'); const bzIndex = headers.indexOf('bz_gsm'); const filteredData = data.slice(1).map((row: any[]) => ({ time: new Date(row[timeIndex]), bt: parseFloat(row[btIndex]) > -9999 ? parseFloat(row[btIndex]) : null, bz: parseFloat(row[bzIndex]) > -9999 ? parseFloat(row[bzIndex]) : null, })).filter((p: any) => p.time >= chartTimeLimit); if (filteredData.length === 0) return; const labels = filteredData.map((p: any) => p.time.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})); const btValues = filteredData.map((p: any) => p.bt); const bzValues = filteredData.map((p: any) => p.bz); const allValues = [...btValues, ...bzValues].filter(v => v !== null); const dataMin = Math.min(...allValues); const dataMax = Math.max(...allValues); const padding = Math.max((dataMax - dataMin) * 0.1, 1); const yMin = Math.floor(dataMin - padding); const yMax = Math.ceil(dataMax + padding); const chartData = { labels, datasets: [ { label: 'Bt (Total)', data: btValues, borderColor: '#A9A9A9', backgroundColor: 'rgba(169, 169, 169, 0.2)', borderWidth: 1.5, tension: 0.3, pointRadius: 0, spanGaps: true }, { label: 'Bz (N/S)', data: bzValues, borderColor: '#FF6347', backgroundColor: 'rgba(255, 99, 71, 0.3)', borderWidth: 1.5, tension: 0.3, pointRadius: 0, spanGaps: true } ] }; if (magneticChart) { magneticChart.data = chartData; magneticChart.options.scales.y.min = yMin; magneticChart.options.scales.y.max = yMax; magneticChart.update(); } else { magneticChart = new (window as any).Chart(ctx, { type: 'line', data: chartData, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: '#a1a1aa' } }, title: { display: false } }, scales: { x: { ticks: { color: '#71717a', maxRotation: 0, autoSkip: true, maxTicksLimit: 24 }, grid: { color: '#3f3f46' } }, y: { min: yMin, max: yMax, ticks: { color: '#71717a' }, grid: { color: (c:any)=>c.tick.value===0?'#fafafa':'#3f3f46', lineWidth:(c:any)=>c.tick.value===0?1.5:1 } } }, interaction: { mode: 'index', intersect: false } } }); } } catch (e) { console.error("Error rendering magnetic chart:", e); }
        }
        async function fetchSensor() {
            try { const [tnrResponse, basicResponse] = await Promise.all([fetch('https://tnr-aurora-forecast.thenamesrock.workers.dev/'), fetch('https://basic-aurora-forecast.thenamesrock.workers.dev/')]); if (!tnrResponse.ok || !basicResponse.ok) throw new Error(`Fetch failed`); const tnrData = await tnrResponse.json(); const basicData = await basicResponse.json(); const scoreValue = parseFloat(tnrData.values.pop().value); (document.getElementById('aurora-score') as HTMLElement).innerHTML = `${scoreValue.toFixed(1)}% <span class="emoji">${getAuroraEmoji(scoreValue)}</span>`; const lastUpdated = new Date(basicData.values.pop().lastUpdated); (document.getElementById('last-updated') as HTMLElement).innerText = `Last Updated: ${lastUpdated.toLocaleDateString()} ${lastUpdated.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`; updateThermometer(scoreValue); updateAuroraBlurb(scoreValue); } catch (error) { (document.getElementById('aurora-score') as HTMLElement).innerHTML = `Error <span class="emoji">❓</span>`; (document.getElementById('last-updated') as HTMLElement).innerText = `Update Failed: ${(error as Error).message}`; updateThermometer(0); updateAuroraBlurb(-1); }
        }
        async function renderAuroraChart() {
            const ctx=auroraChartRef.current?.getContext('2d'); if (!ctx) return;
            try{const[r1,r2]=await Promise.all([fetch('https://basic-aurora-forecast.thenamesrock.workers.dev/'),fetch('https://tnr-aurora-forecast.thenamesrock.workers.dev/')]);const j1=await r1.json(),j2=await r2.json();const d1=j1.values.sort((a:any,b:any)=>new Date(a.lastUpdated).getTime()-new Date(b.lastUpdated).getTime()),d2=j2.values.sort((a:any,b:any)=>new Date(a.lastUpdated).getTime()-new Date(b.lastUpdated).getTime());const l:any[]=[],p1:any[]=[],p2:any[]=[];const n=new Date(),s=new Date(Math.floor((n.getTime()-10800000)/300000)*300000);let v1:any=null,v2:any=null,i1=0,i2=0;for(let t=new Date(s);t<=n;t.setTime(t.getTime()+300000)){l.push(t.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'}));while(i1<d1.length&&new Date(d1[i1].lastUpdated)<=t)v1=parseFloat(d1[i1++].value);p1.push(v1);while(i2<d2.length&&new Date(d2[i2].lastUpdated)<=t)v2=parseFloat(d2[i2++].value);p2.push(v2)}
            const cD={labels:l,datasets:[{label:'Base Score',data:p1,borderColor:'#A9A9A9',backgroundColor:'rgba(169,169,169,0.2)',tension:.4,borderWidth:1.5,pointRadius:0},{label:'Real Score',data:p2,borderColor:'#FF6347',backgroundColor:'rgba(255,99,71,0.3)',tension:.4,borderWidth:1.5,pointRadius:0}]};
            if(auroraChartInstance){auroraChartInstance.data=cD;auroraChartInstance.update()}else{auroraChartInstance=new (window as any).Chart(ctx,{type:'line',data:cD,options:{responsive:!0,maintainAspectRatio:!1,plugins:{legend:{labels:{color:'#a1a1aa'}},title:{display:!1}},scales:{x:{ticks:{color:'#71717a'},grid:{color:'#3f3f46'}},y:{min:0,max:100,ticks:{color:'#71717a'},grid:{color:'#3f3f46'}}},interaction:{mode:'index',intersect:!1}}})}}catch(e){console.error("Error rendering aurora chart:",e)}
        }

        const runAllUpdates = () => { apiDataCache = {}; fetchSensor(); renderAuroraChart(); Object.keys(GAUGE_API_ENDPOINTS).forEach(type => updateGauge(type)); renderMagneticChart(); };
        runAllUpdates();
        const intervalId = setInterval(runAllUpdates, UPDATE_INTERVAL_MS);
        return () => clearInterval(intervalId);
    }, []);

    return (
        <div className="container p-4 md:p-5" style={{ color: 'var(--text-secondary)' }}>
            <main className="dashboard-grid">
                <div id="nz-spotlight" className="card"><div id="aurora-score-display"><h2 className="card-title">NZ West Coast Aurora Chance</h2><div id="aurora-score">Loading...</div><div id="thermometer-container"><div id="thermometer-line"></div></div><div id="last-updated">Last Updated: Loading...</div></div><div id="aurora-blurbs"><div className="aurora-blurb" id="blurb-10">Little to no auroral activity.</div><div className="aurora-blurb" id="blurb-25">Minimal auroral activity likely.</div><div className="aurora-blurb" id="blurb-40">Clear auroral activity visible in cameras.</div><div className="aurora-blurb" id="blurb-50">Faint auroral glow potentially visible to the naked eye.</div><div className="aurora-blurb" id="blurb-80">Good chance of seeing naked-eye auroral color.</div><div className="aurora-blurb" id="blurb-80plus">High probability of significant auroral substorms.</div></div></div>
                <div className="gauge-grid"><div className="card gauge"><h3 className="card-title">Hemispheric Power</h3><div className="gauge-value" id="power-value">...</div><div className="gauge-emoji" id="power-emoji">...</div><div className="gauge-bar-track"><div className="gauge-bar" id="power-gauge-bar"></div></div><div className="gauge-last-updated" id="power-last-updated">...</div></div><div className="card gauge"><h3 className="card-title">Solar Wind Speed</h3><div className="gauge-value" id="speed-value">...</div><div className="gauge-emoji" id="speed-emoji">...</div><div className="gauge-bar-track"><div className="gauge-bar" id="speed-gauge-bar"></div></div><div className="gauge-last-updated" id="speed-last-updated">...</div></div><div className="card gauge"><h3 className="card-title">Solar Wind Density</h3><div className="gauge-value" id="density-value">...</div><div className="gauge-emoji" id="density-emoji">...</div><div className="gauge-bar-track"><div className="gauge-bar" id="density-gauge-bar"></div></div><div className="gauge-last-updated" id="density-last-updated">...</div></div><div className="card gauge"><h3 className="card-title">IMF Bt (Total)</h3><div className="gauge-value" id="bt-value">...</div><div className="gauge-emoji" id="bt-emoji">...</div><div className="gauge-bar-track"><div className="gauge-bar" id="bt-gauge-bar"></div></div><div className="gauge-last-updated" id="bt-last-updated">...</div></div><div className="card gauge"><h3 className="card-title">IMF Bz (N/S)</h3><div className="gauge-value" id="bz-value">...</div><div className="gauge-emoji" id="bz-emoji">...</div><div className="gauge-bar-track"><div className="gauge-bar" id="bz-gauge-bar"></div></div><div className="gauge-last-updated" id="bz-last-updated">...</div></div></div>
                <div className="card chart-card"><h2 className="card-title">Aurora Visibility (Past 3 Hours)</h2><canvas ref={auroraChartRef}></canvas></div>
                <div className="card chart-card"><h2 className="card-title">Magnetic Field Components (Past 24 Hours)</h2><canvas ref={magneticChartRef}></canvas></div>
            </main>
        </div>
    );
};

export default ForecastDashboard;